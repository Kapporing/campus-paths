{"version":3,"sources":["CampusMap.tsx","Pathfinder.tsx","App.tsx","index.tsx"],"names":["validPoints","Map","CampusMap","props","canvas","currentClickedPair","entrancesList","selectedMainBuilding","pageReset","drawBigBuildings","ctx","temp","centralBuilding","validpt","forEach","value","key","point","set","x","y","beginPath","lineWidth","strokeStyle","arc","Math","PI","stroke","drawBuildingPoints","i","buildings","length","drawPath","tuples","start","undefined","options","hogWild","fillStyle","floor","random","fill","moveTo","rainbow","lineTo","setState","directionPage","changePage","change","currPage","state","calcWaypoints","vertices","waypoints","pt0","pt1","dx","dy","sep","j","push","animateLine","pointRender","slice","max","pts","animate","t","points","requestAnimationFrame","handleClick","event","current","rect","getBoundingClientRect","clientX","left","clientY","top","cs","getComputedStyle","width","parseInt","getPropertyValue","scaleFactor","actualX","actualY","k","v","abs","buildingMatches","get","showModal","handleMultipleEntrances","shortName","sendPath","list","assert","entrance","longName","replace","sname","ToggleButton","onChange","setEntranceOption","target","setShow","show","acceptEntrance","backgroundImage","React","createRef","this","fetchAndSaveImage","drawBackgroundImage","Error","getContext","pointTuples","toAnimate","background","Image","onload","src","height","drawImage","directions","infoBox","pages","count","ListGroup","Item","variant","str","Modal","onHide","centered","Header","closeButton","Title","Body","className","ToggleButtonGroup","type","name","Footer","Button","onClick","Container","fluid","Row","Col","xs","sm","md","lg","xl","ref","Pagination","Prev","Next","ProgressBar","now","min","Component","Pathfinder","onStartChange","selectedIndex","startingPoint","getAttribute","startPointLong","startLongname","onEndChange","endingPoint","endPointLong","end","endLongname","findPath","axios","post","encodeURIComponent","then","res","getPathFinished","catch","err","showError","response","data","path","sendDirections","json","segment","updatePoints","updateDirections","clearPath","setHogWild","newOpt","updateOptions","setRainbow","setAnimate","id","map","buildingsMap","Form","Group","Label","Control","as","ButtonGroup","DropdownButton","title","OverlayTrigger","placement","delay","hide","overlay","Tooltip","Dropdown","active","Divider","current_state","clickedPaths","st","st_long","en","App","showConnectionFailure","connectionFailure","loadBuildings","newMap","buildingsList","buildingNames","hasOwnProperty","item","parseBuildings","buildingsLoaded","bld","substring","has","updatePointsList","dirs","opt","drawOptions","pointToPoint","alert","Spinner","style","position","animation","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a3e73da3.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport {CampusBuilding, Options} from './App';\nimport \"./CampusMap.css\";\nimport {\n    Button,\n    Col,\n    Container,\n    ListGroup,\n    Modal,\n    Pagination,\n    ProgressBar,\n    Row,\n    ToggleButton,\n    ToggleButtonGroup\n} from \"react-bootstrap\";\nimport assert from \"assert\";\n\ninterface CampusMapState {\n    backgroundImage: HTMLImageElement | null;       // Stores the background image\n    directionPage: number;                          // Stores the current page in which the direction 'page' is at.\n    showModal: boolean;                             // Determines whether pop-up from selecting multiple entrance is shown\n    entrance: string;                               // The current entrance chosen.\n}\n\ninterface CampusMapProps {\n    // List of tuples representing a point (intersection) of paths (or buildings) -- used for drawing\n    points: [number, number][];\n    // List of English direction. Either empty or in form of [\"Path from A to B\", ..., \"Total distance: ... feet\"] -- used to give english directions\n    directions: string[];\n    // List of buildings, see App.CampusBuilding interface for layout   -- used to draw all possible entry points (can be removed)\n    buildings: CampusBuilding[];\n    // Map of \"main\" building/entrance to a list of all entrances in the same building (i.e KNE (S) -> KNE(S), KNE, KNE(SW) ...)  -- used for click navigation\n    // NOTE: Key of map does not necessarily have to be the building name without the entrance like above^\n    centralBuilding: Map<string, CampusBuilding[]>;\n    // Sends a request to pathFinder that a point in the map has been clicked.  -- used for click navigation\n    sendPath(start: string, end: string): void;\n    // Experimental!!\n    options: Options;\n}\n\nlet validPoints: Map<string, [number, number]> = new Map();\n\n\nclass CampusMap extends Component<CampusMapProps, CampusMapState> {\n\n    // NOTE:\n    // This component is a suggestion for you to use, if you would like to.\n    // It has some skeleton code that helps set up some of the more difficult parts\n    // of getting <canvas> elements to display nicely with large images.\n    //\n    // If you don't want to use this component, you're free to delete it.\n\n    canvas: React.RefObject<HTMLCanvasElement>;\n    currentClickedPair: [string, string];\n    entrancesList: any[];\n    selectedMainBuilding: string;\n    pageReset: boolean;\n\n\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            backgroundImage: null,\n            directionPage: 0,\n            showModal: false,\n            entrance: \"\"\n        };\n        this.canvas = React.createRef();\n        this.currentClickedPair = [\"\", \"\"];\n        this.entrancesList = [];\n        this.selectedMainBuilding = \"\";\n        this.pageReset = false;\n    }\n\n    componentDidMount() {\n        // Might want to do something here?\n        this.fetchAndSaveImage();\n    }\n\n    /**\n     * After updating, make sure to draw the path (if any exists)\n     * putting draw buildings here was the only workaround to having setState be asynchronous in app\n     * (i.e cannot send a parsed list of centralMap(building->list of entrances))\n     */\n    componentDidUpdate() {\n        // Might want something here too...\n        this.drawBackgroundImage();\n        let canvas = this.canvas.current;\n        if (canvas === null) throw Error(\"Unable to draw, no canvas ref.\");\n        let ctx = canvas.getContext(\"2d\");\n        if (this.props.points.length !== 0){\n            let pointTuples: [number, number][] = this.props.points;\n            if (this.props.options.toAnimate) {\n                this.animateLine(ctx, pointTuples);\n            } else {\n                this.drawPath(ctx, pointTuples);\n            }\n        }\n        // this.drawBuildingPoints(ctx);        // may be useful later on? draws all possible entrances\n        this.drawBigBuildings(ctx);\n    }\n\n    fetchAndSaveImage() {\n        // Creates an Image object, and sets a callback function\n        // for when the image is done loading (it might take a while).\n        let background: HTMLImageElement = new Image();\n        background.onload = () => {\n            this.setState({\n                backgroundImage: background\n            });\n        };\n        // Once our callback is set up, we tell the image what file it should\n        // load from. This also triggers the loading process.\n        background.src = \"./campus_map.jpg\";\n    }\n\n    /**\n     * Draws the background image stored in the canvas\n     */\n    drawBackgroundImage() {\n        let canvas = this.canvas.current;\n        if (canvas === null) throw Error(\"Unable to draw, no canvas ref.\");\n        let ctx = canvas.getContext(\"2d\");\n        if (ctx === null) throw Error(\"Unable to draw, no valid graphics context.\");\n        //\n        if (this.state.backgroundImage !== null) { // This means the image has been loaded.\n            // Sets the internal \"drawing space\" of the canvas to have the correct size.\n            // This helps the canvas not be blurry.\n            canvas.width = this.state.backgroundImage.width;\n            canvas.height = this.state.backgroundImage.height;\n            ctx.drawImage(this.state.backgroundImage, 0, 0);\n        }\n    }\n\n    /**\n     * Draws the \"main\" buildings determined by the key of the centralMap.\n     * ** maybe try to do some offsetting?\n     * (i.e if main building is KNE (N) then draw it a bit more to the south to get actual location) **\n     *\n     * @param ctx: CanvasRenderingContext2D object, used to draw a circle around each building\n     */\n    drawBigBuildings = (ctx: any) => {\n        let temp = this.props.centralBuilding;\n        let validpt: Map<string, [number, number]> = new Map();\n        temp.forEach(function(value, key) {\n            let point = value[0];\n            validpt.set(key, [point.x, point.y]);\n            ctx.beginPath();\n            ctx.lineWidth = 15;\n            ctx.strokeStyle = \"#4B2E83\";        // UW's purple\n            ctx.arc(point.x, point.y, 25, 0, 2 * Math.PI);\n            ctx.stroke();\n        });\n\n        validPoints = validpt;\n    };\n\n    /**\n     * Draws ALL possible entrances and buildings\n     *\n     * @param ctx: CanvasRenderingContext2D object, used to draw a circle around each building\n     */\n    drawBuildingPoints = (ctx: any) => {\n        for (let i = 0; i < this.props.buildings.length; i++) {\n            let point = this.props.buildings[i];\n            ctx.beginPath();\n            ctx.lineWidth = 5;\n            ctx.strokeStyle = \"purple\";\n            ctx.arc(point.x, point.y, 25, 0, 2 * Math.PI);\n            ctx.stroke();\n        }\n    }\n\n    /**\n     * Draws a path (if any) from start: [ tuples[0][0], tuples[0][1] ]\n     *                       to   end: [ tuples[tuples.length - 1][0], tuples[tuples.length - 1][1] ]\n     *\n     * @param ctx CanvasRenderingContext2D object, used to draw the lines\n     * @param tuples a size 2 list of [number, number] tuples with the start [x,y] at idx 0 and end[x,y] at tuples.length - 1\n     */\n    drawPath = (ctx: any, tuples: [number, number][]) => {\n        // Find the starting point first.\n        let start: [number, number] = tuples[0];\n\n        // If the start is valid (i.e tuples != empty), draw\n        if (start !== undefined) {\n            // Draws a circle on start/end point\n            ctx.beginPath();\n            if (this.props.options.hogWild) {\n                ctx.fillStyle = 'hsl('+ Math.floor(Math.random() * 361) + ',100%,50%)';\n            } else {\n                ctx.fillStyle = \"yellow\";\n            }\n            ctx.arc(start[0], start[1], 25, 0, 2 * Math.PI);\n            ctx.fill();\n\n            ctx.beginPath();\n            if (this.props.options.hogWild) {\n                ctx.fillStyle = 'hsl('+ Math.floor(Math.random() * 361) + ',100%,50%)';\n            } else {\n                ctx.fillStyle = \"yellow\";\n            }\n            ctx.arc(tuples[tuples.length - 1][0],tuples[tuples.length - 1][1],25, 0, 2 * Math.PI);\n            ctx.fill();\n\n            // Draws the paths between start and end\n\n            let i: number;\n            for (i = 0; i < tuples.length - 1; i++) {\n                ctx.beginPath();\n                ctx.lineWidth = 15;\n                ctx.moveTo(tuples[i][0], tuples[i][1]);\n                if (this.props.options.rainbow) {\n                    ctx.strokeStyle = 'hsl('+ 360*(i / (tuples.length - 1)) + ',100%,50%)';\n                } else if (this.props.options.hogWild) {\n                    ctx.strokeStyle = 'hsl('+ Math.floor(Math.random() * 361) + ',100%,50%)';\n                } else {\n                    ctx.strokeStyle = \"red\";\n                }\n                ctx.lineTo(tuples[i + 1][0], tuples[i + 1][1]);\n                ctx.stroke();\n            }\n        }\n\n        if (this.pageReset) {\n            this.pageReset = false;\n            this.setState({directionPage: 0});\n        } else {\n            this.pageReset = true;\n        }\n    };\n\n    /**\n     * Changes the page of directions based on increment value\n     *\n     * @param change the increment value (negative for decrement)\n     */\n    changePage = (change: number) => {\n        let currPage: number = this.state.directionPage;\n        currPage += change;\n        this.setState({\n            directionPage: currPage\n        });\n        this.pageReset = false;\n    }\n\n\n    calcWaypoints = (vertices: [number, number][]) =>{\n        let waypoints: [number, number][] = [];\n        for(let i = 1;i < vertices.length; i++){\n            let pt0 = vertices[i-1];\n            let pt1 = vertices[i];\n            let dx = pt1[0] - pt0[0];\n            let dy = pt1[1] - pt0[1];\n            let sep = 10;\n            if (dx < 50 && dy < 50) {\n                sep = 3;\n            }\n            for(let j = 0; j < sep; j++){\n                let x = pt0[0] + dx * j/sep;\n                let y = pt0[1] + dy * j/sep;\n                waypoints.push([x, y]);\n            }\n        }\n        return waypoints;\n    }\n\n    animateLine = (ctx: any, tuples: [number, number][]) => {\n        let start: [number, number] = tuples[0];\n        ctx.beginPath();\n        if (this.props.options.hogWild) {\n            ctx.fillStyle = 'hsl('+ Math.floor(Math.random() * 361) + ',100%,50%)';\n        } else {\n            ctx.fillStyle = \"yellow\";\n        }\n        ctx.arc(start[0], start[1], 25, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.arc(tuples[tuples.length - 1][0],tuples[tuples.length - 1][1],25, 0, 2 * Math.PI);\n        ctx.fill();\n        let pointRender = tuples.slice(0, Math.max((this.state.directionPage + 1) * 10, 0));\n        let pts = this.calcWaypoints(pointRender);\n        let t = 1;\n        this.animate(ctx, t, pts);\n\n        if (this.pageReset) {\n            this.pageReset = false;\n            this.setState({directionPage: 0});\n        } else {\n            this.pageReset = true;\n        }\n    }\n\n    animate = (ctx: any, t: number, points: [number, number][]) => {\n        if(t < points.length-1){\n            requestAnimationFrame(() => this.animate(ctx, t, points));\n        }\n        // draw a line segment from the last waypoint\n        // to the current waypoint\n        ctx.beginPath();\n        if (this.props.options.rainbow) {\n            ctx.strokeStyle = 'hsl('+ 360*(t / (points.length - 1)) + ',100%,50%)';\n        } else if (this.props.options.hogWild) {\n            ctx.strokeStyle = 'hsl('+ Math.floor(Math.random() * 361) + ',100%,50%)';\n        } else {\n            ctx.strokeStyle = \"red\";\n        }\n        ctx.moveTo(points[t-1][0],points[t-1][1]);\n        ctx.lineTo(points[t][0],points[t][1]);\n        ctx.stroke();\n        // increment \"t\" to get the next waypoint\n        t++;\n    }\n\n    /**\n     * Handles a click on the map by getting the scaled down x, y coordinate of the click and converting it to\n     * actual x,y coordinates and then getting the short name of the point that is ~40px radius near the click site\n     *\n     * @param event: Mouse Click Event\n     */\n    handleClick = (event: any) => {\n        let canvas = this.canvas.current;       // Gets the current version of the canvas\n        if (canvas !== null) {\n            // First few parts of code courtesy of stackoverflow\n            // @see https://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element by patriques\n            const rect = canvas.getBoundingClientRect();        // Gets the bounding rectangle\n            const x = event.clientX - rect.left;                // Gets the x coordinate of the click position relative to the bounds\n            const y = event.clientY - rect.top;                 // Gets the y coordinate of the click position relative to the bounds\n\n            // Gets the scaled width (and height) of the scaled down canvas size\n            let cs     = getComputedStyle(canvas);\n            let width  = parseInt(cs.getPropertyValue('width'), 10);\n            // let height = parseInt(cs.getPropertyValue('height'), 10);\n\n            // Gets the scaling factor of the canvas with respect to the actual size and get the actualX and actualY coordinates\n            let scaleFactor = canvas.width / width;\n            let actualX = x * scaleFactor;\n            let actualY = y * scaleFactor;\n\n            // For each of the coordinates in validPoints (list of map of \"main\" building shortName -> its [x,y] tuple coordinates),\n            // check for a match, if there is a match, get the list of CampusBuildings associated with that \"main building\"\n            // @ts-ignore\n            for (let [k, v] of validPoints) {\n                // Checks to see if click is within 40px radius of a point\n                //(might be flawed since it checks in order as opposed to closest distance)\n                if (Math.abs(v[0] - actualX) <= 40 && Math.abs(v[1] - actualY) <= 40) {\n                    // Gets the list of entrances tied to the main building\n                    let buildingMatches: CampusBuilding[] = this.props.centralBuilding.get(k)!;\n                    // If there are more than one entrance, pop-up the other entrances select box\n                    if (buildingMatches.length !== 1) {\n                        this.setState({\n                           showModal: true\n                        });\n                        this.handleMultipleEntrances(buildingMatches);\n                    } else {\n                        // If there is only one entrance, send it over to PathFinder\n                        let point: string = buildingMatches[0].shortName;\n                        // Checks to see if it's a start or end based on the current pair fillings\n                        if (this.currentClickedPair[0] === \"\") {\n                            this.currentClickedPair[0] = point;\n                            this.props.sendPath(point, \"\");\n                        } else {\n                            this.currentClickedPair[1] = point;\n                        }\n                    }\n                }\n            }\n\n            // If both pairs are filled, send it over to pathFinder (it sends if either start/end fills, actually)\n            if (this.currentClickedPair[0] !== \"\" && this.currentClickedPair[1] !== \"\") {\n                this.props.sendPath(this.currentClickedPair[0], this.currentClickedPair[1]);\n                this.currentClickedPair = [\"\", \"\"];\n            }\n        }\n    }\n\n    /**\n     * Handles the case with multiple entrances by creating a list of <ToggleButtons> (i.e Radio Buttons)\n     * with the corresponding shortName as its value to be shown to the Modal pop-up\n     *\n     * @param list list of possible entrances tied to the \"main\" building\n     */\n    handleMultipleEntrances = (list: CampusBuilding[]) => {\n        this.entrancesList = [];              // Sets the current entranceList to be empty (clears out previous runs)\n        assert(list.length > 0);        // Make sure the value of list is > 0 (it should be because the only time this is called is inside the above function)\n        // Since setState is asynchronous, we want to make sure we call it ahead of time (saves a few ms probably?)\n        // Sets the current chosen list to be the first possible entrance (default value for radio buttons)\n        this.setState({\n            entrance: list[0].shortName\n        });\n        this.selectedMainBuilding = list[0].longName.replace( /\\s\\(.*\\)/, \"\");\n        // For all possible entrances, create a RadioButton with a unique key and value set to be its shortName\n        for (let i = 0; i < list.length; i++) {\n            let sname: string = list[i].shortName;\n            this.entrancesList.push(\n                <ToggleButton key={i} value={sname} onChange={this.setEntranceOption}>{sname}</ToggleButton>\n            );\n            // NOTE: onChange function just sets the state of entrance to be whatever the user has picked.\n        }\n    }\n\n    /**\n     * Sets the current chosen entrance\n     *\n     * @param event\n     */\n    setEntranceOption = (event: any) => {\n        this.setState({\n            entrance: event.target.value\n        });\n    }\n\n    /**\n     * Sets the state of modal (i.e whether to show or not)\n     *\n     * @param show boolean determining whether to show\n     */\n    setShow = (show: boolean) => {\n        this.setState({\n            showModal: show\n        });\n    }\n\n    /**\n     * Confirms the user's selection of entrance by closing the modal and sending the start/end pair\n     * Determines the start/end when point is clicked in the same way as a single-option handleClick\n     */\n    acceptEntrance = () => {\n        this.setShow(false);\n        let point: string = this.state.entrance;\n        if (this.currentClickedPair[0] === \"\") {\n            this.currentClickedPair[0] = point;\n            this.props.sendPath(point, \"\");\n        } else {\n            this.currentClickedPair[1] = point;\n        }\n\n        if (this.currentClickedPair[0] !== \"\" && this.currentClickedPair[1] !== \"\") {\n            this.props.sendPath(this.currentClickedPair[0], this.currentClickedPair[1]);\n            this.currentClickedPair = [\"\", \"\"];\n        }\n    }\n\n    render() {\n        let directions: any[] = [];     // The list of directions that will be showed per page\n        let infoBox: any[] = [];        // infoBox is the 'header' for the directions (i.e Path from ... and Total distance ...)\n        let pages: any[][] = [];        // List of pages with list of directions (i.e page[idx, directionsList[]]\n        let count: number = 0;          // current count of directions per page (used in partitioning directions to pages)\n\n        if (this.props.points.length !== 0)  {      // If there exists a Path,\n            // Check if the path is not found, in this case we use a special value of [-1, -1] in the props.points\n            if (this.props.points[0][0] === -1 && this.props.points[0][1] === -1) {\n                infoBox.push(<ListGroup.Item variant=\"warning\" key={-1}>No Directions Found</ListGroup.Item>)\n            } else {        // If there are valid directions/path, we add them to the directions\n                // push the first item of directions to infoBox, the first item\n                // is always guaranteed to be the Path from ... if points.length != 0\n                infoBox.push(<ListGroup.Item variant=\"info\" key={0}>{this.props.directions[0]}</ListGroup.Item>);\n                let i;\n                for (i = 1; i < this.props.directions.length - 1; i++) {\n                    const str = this.props.directions[i];\n                    directions.push(<ListGroup.Item key={i}>{str}</ListGroup.Item>);\n                    count++;\n                    // Our max directions per page is 10, so for every 10 directions, create a page with the corresponding directions list\n                    if (count % 10 === 0) {\n                        pages.push(directions);\n                        directions = [];\n                    }\n                }\n                // [i] will always be a valid index because the props.points.length is always > 2 or 0\n                infoBox.push(<ListGroup.Item variant=\"dark\" key={i}>{this.props.directions[i]}</ListGroup.Item>);\n                // If there are still remaining items on the directions, add them in the last page\n                // (i.e if directions is not a proper multiple of 10)\n                if (directions.length > 0) {\n                    pages.push(directions);\n                }\n            }\n        }\n\n        return (\n            <>\n            <Modal show={this.state.showModal} onHide={() => this.setShow(false)} centered>\n                <Modal.Header closeButton>\n                    <Modal.Title>Select Entrance</Modal.Title>\n                </Modal.Header>\n                <Modal.Body>\n                    <div className=\"text-center\">\n                        <h5>{this.selectedMainBuilding}</h5>\n                        <ToggleButtonGroup type=\"radio\" name=\"options\" className=\"button-center\">\n                            {this.entrancesList}\n                        </ToggleButtonGroup>\n                    </div>\n                </Modal.Body>\n                <Modal.Footer>\n                    <Button variant=\"primary\" onClick={this.acceptEntrance}>\n                        Accept\n                    </Button>\n                </Modal.Footer>\n            </Modal>\n\n            <Container fluid>\n                <Row>\n                    <Col xs={12} sm={12} md={12} lg={10} xl={10}>\n                        <canvas ref={this.canvas} onClick={this.handleClick}/>\n                    </Col>\n                    <Col>\n                        <br/>\n                        <ListGroup>\n                            {infoBox}\n                        </ListGroup>\n                        <br/>\n                        {pages.length === 0 ? null :\n                           (<>\n                               <Pagination className=\"text-center\">\n                                   <Pagination.Prev onClick={this.state.directionPage > 0\n                                                            ? () => this.changePage(-1)\n                                                            : () => {this.pageReset = false;this.setState({directionPage: pages.length - 1})}}/>\n                                   <Pagination.Next onClick={this.state.directionPage < pages.length - 1\n                                                            ? () => this.changePage(+1)\n                                                            : () => this.setState({directionPage: 0})}/>\n                               </Pagination>\n                               <ProgressBar now={Math.min(((this.state.directionPage + 1) * 10 / count) * 100, 100)}/>\n                           </>)}\n                        <ListGroup  variant=\"flush\">\n                            {pages[this.state.directionPage]}\n                        </ListGroup>\n                    </Col>\n                </Row>\n            </Container>\n            </>\n        );\n    }\n}\n\nexport default CampusMap;","import React, {Component} from 'react';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport axios, {AxiosResponse} from \"axios\";\nimport './Pathfinder.tsx';\nimport {\n    Col,\n    Container,\n    Row,\n    Form,\n    Button,\n    ButtonGroup,\n    Modal,\n    Dropdown,\n    DropdownButton,\n    Tooltip, OverlayTrigger\n} from \"react-bootstrap\";\nimport {Options} from \"./App\";\n\ninterface PathfinderState {\n    start: string;              // The start point of the pathfinder in Short-Name of building basis\n    end: string;                // The end point of the pathfinder in Short-Name of building basis\n    startLongname: string;      // The start point of the pathfinder in Long-Name of building basis\n    endLongname: string;        // The end point of the pathfinder in Long-Name of building basis\n    showError: [boolean, string];\n    // Experimental!!\n    options: Options;\n}\n\ninterface PathfinderProps {\n    buildingsMap: Map<string, string>;         // The list of buildings passed down from the parent\n    updatePoints(pointTuples: any): void;       // onChange, update the points to connect to pass to the CampusMap to draw\n    updateDirections(directions: any): void;    // onChange, update the list of directions to pass to CampusMap\n    clickedPaths: [string, string];             // Passed down from parent to reflect a request of path from user's clicks\n    // Experimental!!\n    updateOptions(opt: Options): void;\n}\n\n/**\n * This class represents a Pathfinder component that includes the Starting/Ending point dropdown menu\n * as well as the Find Path/Clear button to search for paths\n */\nclass Pathfinder extends Component<PathfinderProps, PathfinderState> {\n\n\n    // Constructor to initialize our state\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            start: \"\",\n            end: \"\",\n            startLongname: \"\",\n            endLongname: \"\",\n            showError: [false, \"\"],\n            options: {\n                hogWild: false,\n                rainbow: false,\n                toAnimate: false\n            }\n        };\n    }\n\n    /**\n     * Used to determine whether an incoming change in prop can change the current state of the Component\n     * Used in determining if the user has clicked on the Map in CampusMap as the only prop we want to\n     * worry about is the clickedPaths prop. If it's not empty, it means the user has clicked on a point\n     *\n     * @param props         The changed props handed over from App\n     * @param current_state The current state of the Component\n     */\n    static getDerivedStateFromProps(props: PathfinderProps, current_state: PathfinderState) {\n        // This if statement checks if the user has inputted another start-point from the map\n        // it works by understanding the fact that the clickedPath tuple always fills in the idx 0\n        // first before idx 1 and that every time a full path is sent, the tuple is set to empty on both idx\n        if (props.clickedPaths[0] !== \"\" && props.clickedPaths[1] === \"\"\n         && current_state.start !== \"\" && current_state.end !== \"\") {\n            props.updatePoints([]);     // Clears out the current drawn path\n            let st = props.clickedPaths[0];\n            let st_long = st === \"\" ? \"\" : st + \" \" + props.buildingsMap.get(st);\n            return {\n                start: st,\n                startLongname: st_long,\n                end: \"\",\n                endLongname: \"\"\n            }\n        }\n        // Checks if it's still in its default state or user has passed in something\n        if (props.clickedPaths[0] !== \"\" || props.clickedPaths[1] !== \"\") {\n            // If the user has clicked on something, to prevent state-locking (meaning the state cannot be changed by our own component),\n            // we have to check if the user has selected something from the dropdown menu\n            // This is because the Dropdown menu still takes priority over the user's clicks\n            if ((current_state.start !== props.clickedPaths[0] && current_state.start === \"\")\n                || (current_state.end !== props.clickedPaths[1] && current_state.end === \"\")) {\n                // If not, we change the state of the object to reflect the user's request of start/end building\n                // from their click\n                let st = props.clickedPaths[0];\n                let st_long = st === \"\" ? \"\" : st + \" \" + props.buildingsMap.get(st);\n\n                let en = props.clickedPaths[1];\n                let en_long = en === \"\" ? \"\" :en + \" \" + props.buildingsMap.get(en);\n                return {\n                    start: st,\n                    startLongname: st_long,\n                    end: en,\n                    endLongname: en_long\n                }\n            }\n        }\n        return null\n    }\n\n    /**\n     * Stores the Short name of the starting building when user changes it using the dropdown menu\n     *\n     * @param event\n     */\n    onStartChange = (event: any) => {\n        // Gets the index of the selected option from the dropdown\n        const selectedIndex = event.target.options.selectedIndex;\n        // Get the key of the option, in this case it's the 'id' value\n        let startingPoint = event.target.options[selectedIndex].getAttribute('id');\n        let startPointLong = event.target.value;\n        this.setState({\n            start: startingPoint,\n            startLongname: startPointLong\n        });\n    };\n\n    /**\n     * Stores the Short name of the ending building when user changes it using the dropdown menu\n     *\n     * @param event\n     */\n    onEndChange = (event: any) => {\n        // Gets the index of the selected option from the dropdown\n        const selectedIndex = event.target.options.selectedIndex;\n        // Get the key of the option, in this case it's the 'id' value\n        let endingPoint = event.target.options[selectedIndex].getAttribute('id');\n        let endPointLong = event.target.value;\n        this.setState({\n            end: endingPoint,\n            endLongname: endPointLong\n        });\n    };\n\n    /**\n     * Finds the path between start/end as determined by the state\n     */\n    findPath = () => {\n        // Gets the start/end points\n        let start = this.state.start;\n        let end = this.state.end;\n\n        // Note that the heroku app wrapper is a workaround for CORS to enable https\n        axios.post(`https://pacific-atoll-14487.herokuapp.com/http://ec2-35-86-242-182.us-west-2.compute.amazonaws.com:4567/path?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}`)\n            .then(res => {\n                this.getPathFinished(res);\n            })\n            .catch(err => {\n                this.setState({\n                    showError: [true, err.response.data]\n                });\n            })\n    };\n\n    /**\n     * Parses the result of looking for paths from start and end, sends the parsed path as well as a list of directions to CampusMap\n     *\n     * @param xhr XMLHttpRequest object that was used to query\n     */\n    getPathFinished = (res: AxiosResponse<any>) => {\n        // If successful, parse it to a JSON object from the JSON format and then send the Path to App->CampusMap\n        this.sendPath(res.data.path);\n        this.sendDirections(res.data.directions);\n    };\n\n    /**\n     * Sends a list of points to be drawn/rendered on CampusMap\n     *\n     * @param json object representing a Path with segments\n     */\n    sendPath = (json: any) => {\n        // Create an array of [x,y] tuples\n        let tuples: [number, number][] = [];\n        // Push the starting [x,y] coordinate pair\n        tuples.push([json.start.x, json.start.y]);\n        // for each segment of the path, push the ending pair *ONLY*\n        for (let segment of json.path) {\n            tuples.push([segment.end.x, segment.end.y]);\n        }\n        // Send it to app via the onChange function\n        this.props.updatePoints(tuples);\n    };\n\n    /**\n     * Sends a list of directions over to CampusMap to display\n     *\n     * @param directions list of directions. Must be formatted exactly either empty or in form of [\"Path from A to B\", ..., \"Total distance: ... feet\"]\n     */\n    sendDirections = (directions: string[]) => {\n        this.props.updateDirections(directions);\n    }\n\n    /**\n     * Clears any path shown on the screen as well\n     * as clear out the dropdown menu\n     */\n    clearPath = () => {\n        this.setState({\n            start: \"\",\n            end: \"\",\n            startLongname: \"\",\n            endLongname: \"\"\n        });\n        this.props.updatePoints([]);\n    }\n\n    setHogWild = () => {\n        let newOpt = this.state.options;\n        newOpt.hogWild = !newOpt.hogWild;\n        newOpt.rainbow = false;\n        this.setState({\n            options: newOpt\n        });\n        this.props.updateOptions(this.state.options);\n    }\n\n    setRainbow = () => {\n        let newOpt = this.state.options;\n        newOpt.rainbow = !newOpt.rainbow;\n        newOpt.hogWild = false;\n        this.setState({\n            options: newOpt\n        });\n        this.props.updateOptions(this.state.options);\n    }\n\n    setAnimate = () => {\n        let newOpt = this.state.options;\n        newOpt.toAnimate = !newOpt.toAnimate;\n        this.setState({\n            options: newOpt\n        });\n        this.props.updateOptions(this.state.options);\n    }\n\n\n    render() {\n        // Dropdown handling.\n        // Create a list of tags and insert all possible buildings to be selected inside the list to be shown\n        // in the dropdown menu later\n        let list: any[] = [];\n        list.push(<option id=\"\" key={-1}/>);\n        let map = this.props.buildingsMap;\n        // @ts-ignore\n        for (let [k, v] of map) {\n            list.push(\n                <option id={k} key ={k}>{k + \" \" + v}</option>\n            );\n        }\n        return (\n            <>\n                <Modal show={this.state.showError[0]} onHide={() => this.setState({showError: [false, \"\"]})} centered>\n                    <Modal.Header closeButton>\n                        <Modal.Title>Error</Modal.Title>\n                    </Modal.Header>\n                    <Modal.Body>\n                        <div className=\"text-center\">\n                            <p className=\"lead\"> {this.state.showError[1]} </p>\n                        </div>\n                    </Modal.Body>\n                    <Modal.Footer>\n                        <Button variant=\"primary\" onClick={() => this.setState({showError: [false, \"\"]})}>\n                            OK\n                        </Button>\n                    </Modal.Footer>\n                </Modal>\n\n                <Container>\n                    <Row>\n                        <Col>\n                            <Form.Group>\n                                <Form.Label>Starting Point</Form.Label>\n                                <Form.Control as=\"select\" value={this.state.startLongname} onChange={this.onStartChange}>\n                                    {list}\n                                </Form.Control>\n                            </Form.Group>\n                        </Col>\n                        <Col>\n                            <Form.Group>\n                                <Form.Label>Ending Point</Form.Label>\n                                <Form.Control as=\"select\" value={this.state.endLongname} onChange={this.onEndChange}>\n                                    {list}\n                                </Form.Control>\n                            </Form.Group>\n                        </Col>\n                        <Col>\n                            <br/>\n                            <ButtonGroup>\n                                <Button variant=\"outline-primary\" onClick={this.findPath}>Find Path</Button>\n                                <Button variant=\"outline-primary\" onClick={this.clearPath}>Clear</Button>\n                                <DropdownButton as={ButtonGroup} title=\"Options\" id=\"bg-nested-dropdown\" variant=\"success\">\n                                    <OverlayTrigger\n                                        placement=\"left\"\n                                        delay={{ show: 250, hide: 250 }}\n                                        overlay={\n                                            <Tooltip id=\"hogwild-tooltip\">\n                                                Randomize color for path-drawing\n                                            </Tooltip>\n                                        }>\n                                        <Dropdown.Item active={this.state.options.hogWild}\n                                                       onClick={this.setHogWild}>\n                                                Random Colors\n                                        </Dropdown.Item>\n                                    </OverlayTrigger>\n\n                                    <OverlayTrigger\n                                        placement=\"left\"\n                                        delay={{ show: 250, hide: 250 }}\n                                        overlay={\n                                            <Tooltip id=\"rainbow-tooltip\">\n                                                Make Path-Color Rainbow\n                                            </Tooltip>\n                                        }>\n                                        <Dropdown.Item active={this.state.options.rainbow}\n                                                       onClick={this.setRainbow}>\n                                            Rainbow\n                                        </Dropdown.Item>\n                                    </OverlayTrigger>\n\n                                    <Dropdown.Divider/>\n\n                                    <OverlayTrigger\n                                        placement=\"left\"\n                                        delay={{ show: 250, hide: 250 }}\n                                        overlay={\n                                            <Tooltip id=\"animate-tooltip\">\n                                                Animate path-drawing\n                                            </Tooltip>\n                                        }>\n                                        <Dropdown.Item active={this.state.options.toAnimate}\n                                                       onClick={this.setAnimate}>\n                                            Animate\n                                        </Dropdown.Item>\n                                    </OverlayTrigger>\n                                </DropdownButton>\n                            </ButtonGroup>\n                        </Col>\n                    </Row>\n                </Container>\n            </>\n        );\n    }\n}\n\nexport default Pathfinder;\n","import React, {Component} from 'react';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport axios, {AxiosResponse} from 'axios';\nimport CampusMap from './CampusMap';\nimport Pathfinder from \"./Pathfinder\";\nimport {Button, Modal, Spinner} from \"react-bootstrap\";\n\nexport interface CampusBuilding {\n    x: number;\n    y: number;\n    shortName: string;\n    longName: string;\n}\n\nexport interface Options {\n    toAnimate: boolean;\n    hogWild: boolean;\n    rainbow: boolean;\n}\n\ninterface AppState {\n    pointTuples: [number, number][];        // Array of [x,y] coordinates to be drawn on the Map\n    buildingsMap: Map<string, string>;         // Map of buildings [short name -> long name]\n    directions: string[];\n    buildings: CampusBuilding[];\n    centralBuilding: Map<string, CampusBuilding[]>;\n    clickedPaths: [string, string];\n    connectionFailure: boolean;\n    buildingsLoaded: boolean;\n    drawOptions: Options;\n}\n\nclass App extends Component<{}, AppState> {\n\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            pointTuples: [],\n            buildingsMap: new Map(),\n            directions: [],\n            buildings: [],\n            centralBuilding: new Map(),\n            clickedPaths: [\"\", \"\"],\n            connectionFailure: false,\n            buildingsLoaded: false,\n            drawOptions: {\n                hogWild: false,\n                rainbow: false,\n                toAnimate: false\n            }\n        };\n        // We want to get a list of all the buildings\n        // to pass down to the Pathfinder component so we can get the dropdown menu\n        // Note that the heroku app wrapper is a workaround for CORS to enable https\n        axios.post('https://pacific-atoll-14487.herokuapp.com/http://ec2-35-86-242-182.us-west-2.compute.amazonaws.com:4567/buildings')\n            .then( res => {\n                this.loadBuildings(res);\n            })\n            .catch(err => {\n                alert(err);\n                this.setState({buildingsLoaded: true});\n            });\n    }\n\n    showConnectionFailure = () => {\n        this.setState({\n            connectionFailure: true\n        });\n    }\n\n    loadBuildings = (res: AxiosResponse<any>) => {\n        let newMap = new Map<string, string>();\n        let buildingsList: CampusBuilding[] = [];\n\n        for (let key in res.data.buildingNames) {\n            if (res.data.buildingNames.hasOwnProperty(key)) {\n                newMap.set(key, res.data.buildingNames[key]);\n            }\n        }\n        for (let i = 0; i < res.data.buildings.length; i++) {\n            const item = res.data.buildings[i] as CampusBuilding;\n            buildingsList.push(item);\n        }\n\n        let map = this.parseBuildings(buildingsList);\n\n        this.setState({\n            buildingsMap: newMap,\n            buildings: buildingsList,\n            centralBuilding: map,\n            buildingsLoaded: true\n        });\n    };\n\n    parseBuildings = (list: CampusBuilding[]) => {\n        let map = new Map<string, CampusBuilding[]>();\n        for (let i = 0; i < list.length; i++) {\n            let bld = list[i];\n            let key = bld.shortName.substring(0, 3);\n            if (map.has(key)) {\n                if (map.get(key) !== undefined) {\n                    let oldList: CampusBuilding[] = map.get(key)!;\n                    oldList.push(bld);\n                }\n            } else {\n                map.set(bld.shortName.substring(0, 3), [bld]);\n            }\n        }\n        return map;\n    }\n\n    updatePointsList = (points: [number, number][]) => {\n        this.setState({\n            pointTuples: points\n        });\n        this.setState({clickedPaths: [\"\", \"\"]});\n    }\n\n    updateDirections = (dirs: string[]) => {\n        this.setState({\n           directions: dirs\n        });\n    }\n\n    updateOptions = (opt: Options) => {\n        this.setState({\n            drawOptions: opt\n        });\n    }\n\n    pointToPoint = (start: string, end: string) => {\n        this.setState({\n            clickedPaths: [start, end]\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                <Modal show={this.state.connectionFailure} onHide={() => this.setState({connectionFailure: false})} centered>\n                    <Modal.Header closeButton>\n                        <Modal.Title>Connection Failure</Modal.Title>\n                    </Modal.Header>\n                    <Modal.Body>\n                        <div className=\"text-center\">\n                            <p>\n                                There's a problem trying to connect to the server. Try again.\n                            </p>\n                        </div>\n                    </Modal.Body>\n                    <Modal.Footer>\n                        <Button variant=\"primary\" onClick={() => this.setState({connectionFailure: false})}>\n                            OK\n                        </Button>\n                    </Modal.Footer>\n                </Modal>\n\n                <h1 className=\"text-center\">Campus-Paths</h1>\n                <Pathfinder clickedPaths={this.state.clickedPaths}\n                            buildingsMap={this.state.buildingsMap}\n                            updatePoints={this.updatePointsList}\n                            updateDirections={this.updateDirections}\n                            updateOptions={this.updateOptions}/>\n\n                {\n                    this.state.buildingsLoaded ?\n                    <CampusMap sendPath={this.pointToPoint}\n                               centralBuilding={this.state.centralBuilding}\n                               buildings={this.state.buildings}\n                               points={this.state.pointTuples}\n                               directions={this.state.directions}\n                               options={this.state.drawOptions}/>\n                    :\n                    <Spinner style={{\n                        position: \"fixed\",\n                        top: \"50%\",\n                        left: \"50%\"\n                    }} animation=\"grow\"/>\n                }\n            </div>\n        );\n    }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}